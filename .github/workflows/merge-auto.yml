name: Auto-Merge PR

on:
  pull_request_review:
    types: [submitted]
  check_run:
    types: [completed]
  status: {}

permissions:
  contents: write
  pull-requests: write

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.event.review.state == 'approved' || github.event.check_run.conclusion == 'success' || github.event.state == 'success'
    
    steps:
      - name: Get PR number
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber;
            
            if (context.payload.pull_request) {
              prNumber = context.payload.pull_request.number;
            } else if (context.payload.review) {
              prNumber = context.payload.review.pull_request.number;
            } else if (context.payload.check_run) {
              const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
                owner: context.repo.owner,
                repo: context.repo.repo,
                commit_sha: context.payload.check_run.head_sha
              });
              if (prs.length > 0) {
                prNumber = prs[0].number;
              }
            }
            
            if (!prNumber) {
              console.log('No PR found');
              return;
            }
            
            core.setOutput('number', prNumber);
            console.log(`PR #${prNumber}`);
      
      - name: Check if ready to auto-merge
        if: steps.pr.outputs.number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = parseInt('${{ steps.pr.outputs.number }}');
            
            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Skip if draft or closed
            if (pr.draft || pr.state !== 'open') {
              console.log('PR is draft or not open, skipping');
              return;
            }
            
            const labels = pr.labels.map(l => l.name);
            console.log(`Labels: ${labels.join(', ')}`);
            
            const isFramework = labels.includes('framework');
            const isTest = labels.some(l => l === 'tests' || l === 'test' || l.includes('test'));
            
            // Only auto-merge test and framework changes
            if (!isFramework && !isTest) {
              console.log('Not a test/framework change, skipping auto-merge');
              return;
            }
            
            console.log(`Framework: ${isFramework}, Test: ${isTest}`);
            
            // Check if all required checks passed
            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            
            const requiredCheck = checks.check_runs.find(c => c.name === 'validate-approvals');
            
            if (!requiredCheck) {
              console.log('validate-approvals check not found yet');
              return;
            }
            
            if (requiredCheck.status !== 'completed' || requiredCheck.conclusion !== 'success') {
              console.log(`validate-approvals status: ${requiredCheck.status}, conclusion: ${requiredCheck.conclusion}`);
              return;
            }
            
            console.log('âœ… All checks passed, attempting auto-merge');
            
            try {
              // Try to enable auto-merge (requires repo settings)
              await github.graphql(`
                mutation($pullRequestId: ID!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: SQUASH
                  }) {
                    pullRequest {
                      autoMergeRequest {
                        enabledAt
                      }
                    }
                  }
                }
              `, {
                pullRequestId: pr.node_id
              });
              
              console.log('âœ… Auto-merge enabled');
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: 'ðŸ¤– Auto-merge enabled - PR will merge automatically once all checks pass'
              });
              
            } catch (error) {
              // If auto-merge feature not available, try direct merge
              console.log('Auto-merge feature not available, attempting direct merge');
              
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  merge_method: 'squash',
                  commit_title: pr.title,
                  commit_message: 'Auto-merged by GitHub Actions'
                });
                
                console.log('âœ… PR merged successfully');
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: 'ðŸŽ‰ PR auto-merged successfully!'
                });
              } catch (mergeError) {
                console.log(`Could not merge: ${mergeError.message}`);
              }
            }
