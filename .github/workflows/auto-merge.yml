name: PR Approval Validation

on:
  pull_request_review:
    types: [submitted, dismissed]
  pull_request:
    types: [labeled, unlabeled]  # Trigger when labels change
  workflow_run:
    workflows: ["PR Change Detector"]  # Replace with actual name
    types: [completed]

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    # Only run on review events or when labels change on open PRs
    if: |
      github.event_name == 'pull_request_review' ||
      (github.event_name == 'pull_request' && github.event.pull_request.state == 'open')
    
    steps:
      - name: Get PR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            let prNumber;
            let pr;
            
            if (context.eventName === 'repository_dispatch') {
              // Get PR from dispatch event (you'll need to pass this)
              console.log('repository_dispatch event - skipping for now');
              return;
            } else {
              prNumber = context.payload.pull_request.number;
            }
            
            if (!prNumber) {
              console.log('No PR found, skipping');
              return;
            }
            
            // Get full PR details
            const { data: prData } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            pr = prData;
            
            core.setOutput('number', pr.number);
            core.setOutput('mergeable', pr.mergeable);
            core.setOutput('draft', pr.draft);
            core.setOutput('state', pr.state);
            core.setOutput('labels', pr.labels.map(l => l.name).join(','));
            
            console.log(`PR #${pr.number}`);
            console.log(`State: ${pr.state}`);
            console.log(`Labels: ${pr.labels.map(l => l.name).join(', ')}`);
            console.log(`Draft: ${pr.draft}`);
            console.log(`Mergeable: ${pr.mergeable}`);
      
      - name: Check auto-merge eligibility
        if: |
          steps.pr.outputs.number != '' && 
          steps.pr.outputs.draft == 'false' &&
          steps.pr.outputs.state == 'open'
        id: check
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          PR_LABELS: ${{ steps.pr.outputs.labels }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const labels = process.env.PR_LABELS.split(',').filter(Boolean);
            
            console.log(`\n=== Checking Auto-Merge for PR #${prNumber} ===`);
            console.log(`Labels found: ${labels.join(', ') || 'none'}`);
            
            // QTF core team members (REPLACE WITH ACTUAL USERNAMES)
            const qtfCoreTeam = [
              'username1',
              'username2',
              'username3'
            ];
            
            // Check for test or framework labels
            const isFrameworkChange = labels.some(l => 
              l === 'type:framework' || 
              l === 'framework' || 
              l.includes('framework')
            );
            
            const isTestChange = labels.some(l => 
              l === 'type:tests' || 
              l === 'type:test' || 
              l === 'test' || 
              l === 'tests'
            );
            
            console.log(`Framework change: ${isFrameworkChange}`);
            console.log(`Test change: ${isTestChange}`);
            
            if (!isFrameworkChange && !isTestChange) {
              console.log('‚è≠Ô∏è  No relevant labels - allowing standard review process');
              core.setOutput('should_merge', 'false');
              core.setOutput('should_comment', 'false');
              return; // Exit successfully - no special rules apply
            }
            
            // Get reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            // Get latest review per user
            const latestReviews = {};
            reviews.forEach(review => {
              const user = review.user.login;
              if (!latestReviews[user] || 
                  new Date(review.submitted_at) > new Date(latestReviews[user].submitted_at)) {
                latestReviews[user] = review;
              }
            });
            
            const approvals = Object.values(latestReviews).filter(r => r.state === 'APPROVED');
            const approvedBy = approvals.map(r => r.user.login);
            const totalApprovals = approvals.length;
            const coreTeamApprovals = approvals.filter(r => qtfCoreTeam.includes(r.user.login));
            
            console.log(`\n=== Approval Status ===`);
            console.log(`Total approvals: ${totalApprovals}`);
            console.log(`Approved by: ${approvedBy.join(', ') || 'none'}`);
            console.log(`Core team approvals: ${coreTeamApprovals.length}`);
            
            let shouldMerge = false;
            let reason = '';
            let shouldFail = false;
            
            if (isTestChange) {
              // Test changes: require 2 approvals from anyone
              if (totalApprovals >= 2) {
                shouldMerge = true;
                reason = `‚úÖ Test change approved (${totalApprovals} approvals). Ready to auto-merge.`;
              } else {
                shouldFail = true;
                reason = `‚ùå Test change requires 2 approvals (currently: ${totalApprovals})`;
              }
            } else if (isFrameworkChange) {
              // Framework changes: require 2 approvals with at least 1 from core team
              if (totalApprovals >= 2 && coreTeamApprovals.length >= 1) {
                shouldMerge = true;
                reason = `‚úÖ Framework change approved (${totalApprovals} approvals, ${coreTeamApprovals.length} from core team). Ready to auto-merge.`;
              } else if (totalApprovals < 2) {
                shouldFail = true;
                reason = `‚ùå Framework change requires 2 approvals (currently: ${totalApprovals})`;
              } else if (coreTeamApprovals.length < 1) {
                shouldFail = true;
                reason = `‚ùå Framework change requires at least 1 approval from QTF core team\nCore team: ${qtfCoreTeam.join(', ')}\nCurrent approvers: ${approvedBy.join(', ')}`;
              }
            }
            
            console.log(`\n=== Decision ===`);
            console.log(reason);
            console.log(`Should merge: ${shouldMerge}`);
            console.log(`Should fail check: ${shouldFail}`);
            
            // Post comment
            if (shouldFail || shouldMerge) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `ü§ñ **Auto-Merge Status**\n\n${reason}`
              });
            }
            
            // FAIL the workflow if requirements not met
            if (shouldFail) {
              core.setFailed(reason);
            }
            
            core.setOutput('should_merge', shouldMerge ? 'true' : 'false');
            core.setOutput('reason', reason);
      
      - name: Post status comment
        if: steps.check.outputs.should_comment == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
          REASON: ${{ steps.check.outputs.reason }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            const reason = process.env.REASON;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: `ü§ñ **Auto-Merge Status**\n\n${reason}`
            });
      
      - name: Check CI status
        if: steps.check.outputs.should_merge == 'true'
        id: ci-status
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            
            // Get commit SHA
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            const sha = pr.head.sha;
            
            // Get all status checks
            const { data: statuses } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha
            });
            
            // Get check runs
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: sha
            });
            
            // Filter out this workflow itself
            const relevantCheckRuns = checkRuns.check_runs.filter(run => 
              run.name !== 'auto-merge' && run.name !== 'Auto-Merge PR'
            );
            
            const allPassed = 
              (statuses.state === 'success' || statuses.statuses.length === 0) &&
              (relevantCheckRuns.length === 0 || relevantCheckRuns.every(run => 
                run.status === 'completed' && 
                (run.conclusion === 'success' || run.conclusion === 'skipped' || run.conclusion === 'neutral')
              ));
            
            console.log(`CI Status: ${statuses.state}`);
            console.log(`Status checks: ${statuses.statuses.length}`);
            console.log(`Check runs (excluding this workflow): ${relevantCheckRuns.length}`);
            
            if (relevantCheckRuns.length > 0) {
              console.log(`Check runs: ${relevantCheckRuns.map(r => `${r.name}: ${r.conclusion}`).join(', ')}`);
            }
            
            core.setOutput('all_passed', allPassed ? 'true' : 'false');
            
            if (!allPassed) {
              console.log('‚è≥ Not all CI checks passed yet');
            }
      
      - name: Enable auto-merge
        if: steps.check.outputs.should_merge == 'true' && steps.ci-status.outputs.all_passed == 'true'
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ steps.pr.outputs.number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            
            // Get PR node_id
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            
            try {
              // Enable auto-merge with squash merge
              await github.graphql(`
                mutation($pullRequestId: ID!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: SQUASH
                  }) {
                    pullRequest {
                      autoMergeRequest {
                        enabledAt
                        enabledBy {
                          login
                        }
                      }
                    }
                  }
                }
              `, {
                pullRequestId: pr.node_id
              });
              
              console.log(`‚úÖ Auto-merge enabled for PR #${prNumber}`);
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: 'üéâ **Auto-merge enabled!** PR will merge automatically once all required checks pass.'
              });
            } catch (error) {
              console.error('Failed to enable auto-merge:', error);
              
              // If auto-merge feature is not available, merge directly
              if (error.message.includes('auto-merge')) {
                console.log('Auto-merge feature not available, attempting direct merge...');
                
                try {
                  await github.rest.pulls.merge({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    merge_method: 'squash',
                    commit_title: pr.title,
                    commit_message: `Auto-merged: All approval requirements met`
                  });
                  
                  console.log(`‚úÖ PR #${prNumber} merged directly`);
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: 'üéâ **PR auto-merged successfully!**'
                  });
                } catch (mergeError) {
                  console.error('Direct merge failed:', mergeError);
                  
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: `‚ö†Ô∏è Auto-merge failed: ${mergeError.message}\n\nPlease merge manually.`
                  });
                }
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `‚ö†Ô∏è Failed to enable auto-merge: ${error.message}\n\nYou may need to enable auto-merge in repository settings.`
                });
              }
            }
